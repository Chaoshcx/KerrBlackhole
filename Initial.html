<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…‹å°”(Kerr)æ—‹è½¬é»‘æ´ - ç‰©ç†é‡æ„ç‰ˆ v3.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #030303; font-family: 'Segoe UI', Tahoma, sans-serif; color: #fff; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui-container {
            position: absolute; top: 25px; left: 25px; width: 380px;
            background: rgba(10, 15, 20, 0.7); border: 1px solid rgba(100, 200, 255, 0.15);
            border-radius: 16px; padding: 25px; backdrop-filter: blur(20px);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9), inset 0 0 0 1px rgba(255,255,255,0.05);
            pointer-events: none; user-select: none;
        }
        h1 {
            font-size: 1.3rem; margin-top: 0; margin-bottom: 20px; text-transform: uppercase;
            letter-spacing: 3px; background: linear-gradient(120deg, #55aaff, #ff4444);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 15px;
        }
        .hud {
            position: absolute; bottom: 30px; right: 30px; font-family: monospace;
            font-size: 0.8rem; color: rgba(100, 200, 255, 0.6); text-align: right; pointer-events: none;
        }
        .hud span { color: #fff; font-weight: bold; }
        .instruction {
            margin-top: 25px; font-size: 0.75rem; color: #888; text-align: center;
            padding-top: 15px; border-top: 1px dashed rgba(255,255,255,0.1); letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>å…‹å°”(Kerr)æ—‹è½¬é»‘æ´ <br><span style="font-size: 0.8rem; color:#888;">ç‰©ç†é‡æ„ç‰ˆ v3.0</span></h1>
        <div class="instruction">
            ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬è§†è§’ | âš™ï¸ æ»šè½®ç¼©æ”¾è·ç¦»
        </div>
    </div>
    
    <div class="hud">
        METRIC: KERR-SCHILD BL-MAPPED<br>
        SPIN [a]: <span>0.99 M</span><br>
        ISCO (PROGRADE): <span>1.453 M</span><br>
        SOLVER: <span>RK3 (Lz CONSERVED)</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const vertexShader = `
            void main() { gl_Position = vec4(position.xy, 0.0, 1.0); }
        `;

        const fragmentShader = `
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec3 u_cameraPos;
            uniform mat4 u_cameraWorldMatrix;
            uniform mat4 u_cameraProjectionMatrixInverse;

            // ä¼˜åŒ–ï¼šç•¥å¾®é™ä½æœ€å¤§æ­¥æ•°ï¼Œä¾é æ›´ç¨³çš„ç§¯åˆ†å™¨å¼¥è¡¥
            #define MAX_STEPS 450 
            
            #define RS 1.0                
            #define M (RS / 2.0)          
            #define SPIN 0.99             
            #define A (SPIN * M)          
            
            #define HORIZON (M + sqrt(max(M*M - A*A, 0.0001))) 
            // ç‰©ç†ä¿®æ­£ï¼ša=0.99M æ—¶çš„é¡ºè¡Œ ISCO ç²¾ç¡®å€¼çº¦ä¸º 1.453M
            #define ISCO (1.453 * M)        
            #define DISK_OUTER (25.0 * RS) 
            #define PI 3.14159265359

            // [å™ªå£°å‡½æ•°çœç•¥ä¿æŒåŸæ ·ï¼Œç²¾ç®€æ˜¾ç¤º]
            float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
            float hash3(vec3 p) { p = fract(p * 0.3183099 + .1); p *= 17.0; return fract(p.x * p.y * p.z * (p.x + p.y + p.z)); }
            float noise(vec2 p) {
                vec2 i = floor(p), f = fract(p); f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x), mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }
            float fbm(vec2 p) {
                float v = 0.0, a = 0.5; mat2 rot = mat2(0.866, -0.5, 0.5, 0.866);
                for (int i = 0; i < 3; ++i) { v += a * noise(p); p = rot * p * 2.2; a *= 0.5; } return v;
            }
            float fbm_bg(vec2 p) {
                float v = 0.0, a = 0.5; mat2 rot = mat2(0.866, -0.5, 0.5, 0.866);
                for (int i = 0; i < 4; ++i) { v += a * noise(p); p = rot * p * 2.0; a *= 0.5; } return v;
            }

            vec3 temperatureToColor(float t) {
                t = max(t, 0.0);
                if (t > 1.8) return mix(vec3(0.8, 0.9, 1.0), vec3(0.5, 0.7, 1.0), clamp((t - 1.8)*0.5, 0.0, 1.0));
                if (t > 1.2) return mix(vec3(1.0, 0.95, 0.8), vec3(0.8, 0.9, 1.0), (t - 1.2) / 0.6);
                if (t > 0.6) return mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.95, 0.8), (t - 0.6) / 0.6);
                if (t > 0.2) return mix(vec3(0.4, 0.05, 0.0), vec3(1.0, 0.5, 0.0), (t - 0.2) / 0.4);
                return mix(vec3(0.0), vec3(0.4, 0.05, 0.0), t / 0.2);
            }

            // ã€ç‰©ç†æ–°å¢ã€‘å°†æ¬§æ°åæ ‡ç³»æ˜ å°„åˆ°çœŸæ­£çš„ Boyer-Lindquist r åæ ‡
            float getBL_r(vec3 pos, float a) {
                float R2 = dot(pos, pos);
                float a2 = a * a;
                float y2 = pos.y * pos.y;
                float temp = R2 - a2;
                return sqrt(0.5 * (temp + sqrt(temp * temp + 4.0 * a2 * y2)));
            }

            vec3 geodesicAccel(vec3 pos, vec3 vel) {
                float r2 = dot(pos, pos);
                if (r2 < 0.001) return vec3(0.0); 
                vec3 L = cross(pos, vel); 
                float h2 = dot(L, L);
                float r = sqrt(r2);
                float r5 = r2 * r2 * r;
                
                // å²ç“¦è¥¿åŸºåº•
                vec3 acc = -1.5 * RS * h2 * pos / r5;
                // å…‹å°”æ‹–æ‹½é¡¹ (Lense-Thirring)
                vec3 J = vec3(0.0, A * M, 0.0); 
                vec3 Bg = (3.0 * pos * dot(pos, J) - r2 * J) / r5; 
                acc += cross(vel, Bg) * 3.5; 
                
                return acc;
            }

            vec3 getBackground(vec3 dir) {
                vec3 color = vec3(0.0);
                float starVal = hash3(dir * 400.0);
                if (starVal > 0.992) color += vec3(1.0, 0.8, 0.6) * pow((starVal - 0.992) * 125.0, 2.0);
                float nebula = fbm_bg(dir.xy * 3.0 + dir.z * 2.0);
                color += vec3(0.05, 0.1, 0.2) * pow(nebula, 3.0);
                color += vec3(0.3, 0.7, 1.0) * exp(-length(dir - normalize(vec3(0.7, 0.25, -0.6))) * 15.0) * 1.5;
                return color;
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
                vec4 target = u_cameraProjectionMatrixInverse * vec4(uv.x, uv.y, 1.0, 1.0);
                vec3 rayDir = (u_cameraWorldMatrix * vec4(normalize(target.xyz / target.w), 0.0)).xyz;
                
                vec3 p = u_cameraPos;
                vec3 v = normalize(rayDir);

                // ã€ç‰©ç†ä¿®æ­£ 2ã€‘åœ¨æ— é™è¿œå¤„è®¡ç®—ä¸¥è°¨çš„è§’åŠ¨é‡å®ˆæ’å€¼ Lz (å…‰å­ç»• y è½´æ—‹è½¬çš„è§’åŠ¨é‡)
                // è¯¥å€¼åœ¨æ•´ä¸ªæµ‹åœ°çº¿è¿åŠ¨ä¸­å®Œå…¨å®ˆæ’ï¼
                float conserved_Lz = p.x * v.z - p.z * v.x;

                vec3 color = vec3(0.0);
                float transmittance = 1.0; 
                vec3 last_p = p;
                bool escaped = false; 

                for (int i = 0; i < MAX_STEPS; i++) {
                    // ã€ç‰©ç†ä¿®æ­£ 1ã€‘ä½¿ç”¨ Boyer-Lindquist r è¿›è¡Œè§†ç•Œåˆ¤å®š
                    float r_bl = getBL_r(p, A);

                    if (r_bl < HORIZON * 1.01) { break; } // è¢«äº‹ä»¶è§†ç•Œåå™¬
                    if (r_bl > 45.0) { escaped = true; break; } // é€ƒé€¸

                    bool crossed = (last_p.y > 0.0 && p.y <= 0.0) || (last_p.y < 0.0 && p.y >= 0.0);
                    if (crossed) {
                        float denom = abs(last_p.y) + abs(p.y);
                        float t = (denom > 0.00001) ? abs(last_p.y) / denom : 0.5;
                        vec3 hitPos = mix(last_p, p, t);
                        float r_hit = getBL_r(hitPos, A); // å¸ç§¯ç›˜åŠå¾„ä¹Ÿè¦ç”¨ BL åæ ‡

                        if (r_hit > HORIZON * 1.02 && r_hit < DISK_OUTER) {
                            float r_v = max(r_hit, ISCO * 0.95);
                            float r_sqrt = sqrt(r_v);
                            float r_15 = r_v * r_sqrt; 
                            
                            // å…‹å°”å¸ç§¯ç›˜å¼€æ™®å‹’è§’é€Ÿåº¦
                            float Omega = sqrt(M) / (r_15 + A * sqrt(M));
                            float v_mag = Omega * r_v; 

                            // å…‹å°”åº¦è§„èµ¤é“é¢åˆ†é‡
                            float g_tt = -(1.0 - RS / r_v); 
                            float g_tphi = -RS * A / r_v;
                            float g_phiphi = r_v * r_v + A * A + RS * A * A / r_v;

                            // è®¡ç®—å››ç»´é€Ÿåº¦æ—¶é—´åˆ†é‡ä¸è§’åˆ†é‡
                            float u_t_inside = -(g_tt + 2.0 * Omega * g_tphi + Omega * Omega * g_phiphi);
                            float u_t = 1.0 / sqrt(max(0.0001, u_t_inside));
                            float u_phi = Omega * u_t;

                            // ã€ç‰©ç†ä¿®æ­£ 3ã€‘ç›´æ¥ä»£å…¥å®ˆæ’å¸¸æ•° Lz è®¡ç®—å¤šæ™®å‹’çº¢ç§»ï¼Œæ‘’å¼ƒå¹³ç›´ç©ºé—´çš„è¿‘ä¼¼ç‚¹ä¹˜ï¼
                            float g_factor = 1.0 / max(0.01, (u_t - u_phi * conserved_Lz)); 
                            g_factor = clamp(g_factor, 0.05, 3.2);

                            float beaming = pow(g_factor, 4.0);
                            float T_emit = pow(ISCO / max(r_hit, ISCO * 0.8), 0.85); 
                            float T_obs = T_emit * g_factor; 

                            // æµä½“è´´å›¾ç”Ÿæˆ
                            float twistAngle = -u_time * v_mag * 1.5 - A / (r_hit * r_hit) * 5.0;
                            float cTwist = cos(twistAngle), sTwist = sin(twistAngle);
                            mat2 rotTwist = mat2(cTwist, -sTwist, sTwist, cTwist);
                            vec2 flowUV = rotTwist * vec2(hitPos.x, hitPos.z) * 0.8;
                            
                            float turbulence = fbm(flowUV + vec2(u_time * 0.3, 0.0));
                            float macro_structure = fbm(flowUV * 0.5 - vec2(u_time * 0.15, 0.0));
                            float rings = sin(r_hit * 12.0 - turbulence * 2.0) * 0.5 + 0.5;
                            rings *= sin(r_hit * 30.0) * 0.5 + 0.5;
                            
                            float structure = pow(max((turbulence * 1.5 + rings * 1.0 + macro_structure) * 0.8, 0.0), 1.5);
                            vec3 baseColor = temperatureToColor(T_obs);

                            float radDist = (r_hit - ISCO) / (DISK_OUTER - ISCO);
                            float innerFade = smoothstep(HORIZON * 1.02, ISCO * 1.2, r_hit);
                            float outerFade = smoothstep(DISK_OUTER, DISK_OUTER * 0.5, r_hit); 
                            
                            float density = exp(-max(radDist, 0.0) * 7.0) * innerFade * outerFade;
                            density += exp(-pow((r_hit - ISCO)*3.0, 2.0)) * 0.5 * innerFade * outerFade;
                            float opacity = clamp(density * structure * 4.5, 0.0, 1.0);

                            vec3 emission = baseColor * beaming * density * structure * 20.0 * opacity;
                            color += transmittance * emission;
                            transmittance *= (1.0 - opacity * 0.95); 
                        }
                    }

                    if (transmittance < 0.01) break;
                    last_p = p;

                    // åŠ¨æ€æ­¥é•¿ï¼šè·ç¦»é»‘æ´è¶Šè¿œï¼Œæ­¥é•¿è¶Šå¤§ï¼ŒèŠ‚çœè®¡ç®—èµ„æº
                    float dt = clamp(0.015 * r_bl * r_bl, 0.005, 0.4);

                    // ã€æ€§èƒ½ä¼˜åŒ–ã€‘å°† RK4 é™é˜¶ä¸ºç»å…¸ RK3 (Simpson's Rule)
                    // åœ¨ç‰ºç‰²æå¾®å°ç²¾åº¦çš„å‰æä¸‹ï¼Œå‡å°‘ 25% çš„çŸ¢é‡çŸ©é˜µæ±‚å¯¼è®¡ç®—
                    vec3 k1_v = geodesicAccel(p, v);
                    vec3 k1_p = v;

                    vec3 k2_v = geodesicAccel(p + k1_p * dt * 0.5, v + k1_v * dt * 0.5);
                    vec3 k2_p = v + k1_v * dt * 0.5;

                    vec3 k3_v = geodesicAccel(p + k2_p * dt * 1.0, v + k2_v * dt * 1.0);
                    vec3 k3_p = v + k2_v * dt * 1.0;

                    p += (k1_p + 4.0 * k2_p + k3_p) * (dt / 6.0);
                    v += (k1_v + 4.0 * k2_v + k3_v) * (dt / 6.0);
                    v = normalize(v); 
                }

                if (escaped && transmittance > 0.01) {
                    color += transmittance * getBackground(v); 
                }

                vec3 bloom = max(color - 2.5, 0.0);
                color += bloom * 0.4;

                // ACES è‰²è°ƒæ˜ å°„
                const float a_aces = 2.51, b_aces = 0.03, c_aces = 2.43, d_aces = 0.59, e_aces = 0.14;
                color = (color * (a_aces * color + b_aces)) / (color * (c_aces * color + d_aces) + e_aces);
                color = pow(color, vec3(1.0 / 2.2)); 

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        let camera, scene, renderer, material, controls;
        let clock = new THREE.Clock();

        function init() {
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.0, 15); camera.lookAt(0, 0, 0);
            scene = new THREE.Scene();
            
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader, fragmentShader: fragmentShader,
                uniforms: {
                    u_time: { value: 0.0 },
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    u_cameraPos: { value: camera.position },
                    u_cameraWorldMatrix: { value: camera.matrixWorld },
                    u_cameraProjectionMatrixInverse: { value: camera.projectionMatrixInverse }
                },
                depthWrite: false, depthTest: false
            });

            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
            mesh.frustumCulled = false; scene.add(mesh);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.25)); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.04;
            controls.minDistance = 3.5; controls.maxDistance = 35.0;
            controls.maxPolarAngle = Math.PI * 0.9;

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
                material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
                material.uniforms.u_cameraProjectionMatrixInverse.value.copy(camera.projectionMatrixInverse);
            });
            animate();
        }

        function animate() {
            requestAnimationFrame(animate); controls.update();
            material.uniforms.u_time.value = clock.getElapsedTime();
            material.uniforms.u_cameraPos.value.copy(camera.position);
            material.uniforms.u_cameraWorldMatrix.value.copy(camera.matrixWorld);
            material.uniforms.u_cameraProjectionMatrixInverse.value.copy(camera.projectionMatrixInverse);
            renderer.render(scene, camera);
        }
        window.onload = init;
    </script>
</body>
</html>